---
layout: post
title: 阅读《深入理解JAVA虚拟机》2(内存区域，垃圾回收)
categories: BookReading
description: 阅读笔记
keywords: 读书
---
深入理解java虚拟机 读书笔记 2

# 第二章 Java内存区域与内存溢出异常
## Java虚拟机规范中规定了虚拟管管理的内存中将会包含以下几个数据区域

### 1.程序计数器（Program Counter Register）
是一块比较小的内存空间，可以看作当前线程所执行的字节码的行号指示器。Java虚拟机中的多线程是通过线程轮流切换并分配处理器执行时间来实现的，所以实际上在任何一个确定的时间一个处理器的内核只能执行一条线程中的指令。即每个线程都会有一个“线程私有”的程序计数器。

### 2.Java虚拟机栈（Java Virtual Machine Stacks）
同样属于**线程私有，生命周期与线程一致**，用于存储方法的局部变量表、操作数栈、动态链表等信息，每个方法从调用到执行完成对应着一个栈帧在这个空间内入栈出栈的过程。粗糙地把Java内存分为“栈”和“堆”的话，这部分就是“栈”。保存了一些编译期可以知道大小的数据结构（boolean、byte等）、对象引用（reference类型，指向对象或者指向代表对象的句柄等）

### 3.本地方法栈（Native Method Stack）
与虚拟机栈发挥的作用类似，区别在于虚拟机栈为虚拟机执行Java方法（字节码）服务，而本地方法栈为虚拟机使用到的Native方法服务。有的虚拟机实现会把这两个栈合并到一起。

### 4.Java堆（Java Heap）
一般是内存中占用最大的一块，被所有线程共享，在虚拟机启动的时创建。用于存放对象实例，实际上程序中动态分配的空间都是从这个区域获取，同时也时垃圾收集器管理的主要区域，所以有“GC堆”（Garbage Collected Heap）的别名。可能划分出多个线程私有的分配缓冲区（Thread Local Allocation Buffer）。

### 5.方法区（Method Area）
与Java堆一样，是各个线程共享的区域，存储已被虚拟机加载的类信息、常量、静态变量等。有一个别名叫Non-Heap，用于和堆区分开。

### 6.运行时常量池（Runtime Constant Pool）
运行时常量池是方法区的一部分。Class文件中除了有类的版本、字段、方法等描述信息以外，还有一项信息是常量池表，用于存放编译期间生成的各种字面量和符号引用。

### 7.直接内存（Direct Memory）
在JDK1.4中加入NIO（New Input/Output）类，引入了一种基于通道与缓冲区的I/O新方式，可以使用Native函数库直接分配堆外内存，然后通过存储在Java堆中的DirectByteBuffer对象作为这块内存的引用进行操作。

### 对象的创建
虚拟机遇到一条new指令时，首先将去检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已经被加载、解析和初始化。加载的工作在这个阶段进行。
接下来虚拟机将为新生对象分配内存，然后将分配到的内存空间都初始化为零值（不包括对象头）。
然后，虚拟机需要对对象进行必要的设置，例如这个对象是哪个类的实例、如何才能找到类的元数据、对象的哈希码等，这些信息都放在对象的对象头中（Object Header）。从虚拟机的角度而言，此时一个新的对象已经产生了，但从Java程序的角度而言，对象的创建才刚开始，需要执行init工作。

### 对象的内存布局
对象在内存中存储的布局可以分为三个区域：对象头（Header）、实例数据（Instance Data）和对象填充（Padding）。对象头包括两个部分，一部分是自身运行时的数据（包括哈希码、GC分代年龄等，如果是数组，那么还需要存储数组的大小），另一部分是类型指针，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。

### 对象的访问定位
Java程序通过栈上的reference数据来操作堆上的具体对象。reference的访问有两种主流实现。
* 句柄
存储对象的句柄地址，句柄中包含了对象实例数据与类型数据各自的具体地址信息。
* 直接指针
堆中需要直接存储类型数据的相关信息，而reference中存储的直接就是对象地址。




# 第三章 垃圾收集器与内存分配策略
## 判断对象已死的方法

### 1. 引用计数算法（Reference Counting）
每当有一个地方引用它时计数器加1；当引用失效时，计数器值减1；任何时刻，计数器为0的对象是不能被使用的。 缺点在于不能处理**对象之间循环引用**的问题。

### 2. 可达性分析算法（Reachability Analysis）
通过一系列称为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链（Reference Chain），当一个对象到GC Roots没有任何引用链相连（即GC Roots到这个对象不可达），则证明这个对象是不可用的。GC Roots包括以下几类
* 虚拟机栈中引用的对象
* 方法区中类静态属性引用的对象
* 方法区中常量引用的对象
* 本地方法栈中JNI（即Native方法）引用的对象

### 判断对象是否存活都和“引用”有关。
从JDK1.2后，对于“引用”的定义有所拓展，能够表示那些介于需要立即回收和不能回收之间的引用对象。即分为4种概念：
* 强引用(Strong Reference)
```类似"Object obj = new Object();"这类引用，只要这样的引用还存在，这个对象就永远不会被系统回收。```
* 软引用(Soft Reference)
```只会在系统内存快要溢出前，这些引用对象才会被列入回收范围。JDK1.2后提供了SoftReference类```
* 弱引用(Weak Reference)
```强度低于软引用，当垃圾收集器开始工作就会回收掉只被弱引用关联的对象。JDK1.2后提供了WeakReference类```
* 虚引用(Phantom Reference)
```最弱的引用，不会对对象的生存时间产生影响。为一个对象设置虚引用，可以在对象被回收的时候收到一个系统通知。JDK1.2后提供了PhantomReference类。```

### 如何被回收
即使在可达性算法中不可达的对象，在死亡之前至少要经历两次标记过程。可达性分析后没有与GC ROOTS相连接的引用链，那么会被第一次标记并进行一次筛选（查看这个对象有没有必要执行finalize()方法）。如果有必要执行，那么这个对象会被放置在一个F-Queue的队列中，然后被一个虚拟机创建的低优先级Finalizer线程执行。如果对象在这个方法里及时和引用链上的任何对象建立关联就能避免死亡。（任何对象的finalize方法只会被调用一次）

### 回收方法区
对于方法区的垃圾回收性价比不太高。在方法区进行垃圾回收主要有两个部分：废弃常量和无用的类。即一个后期没有被任何对象引用的常量值。而判定一个废弃类要求比较严苛：
* 该类的所有实例都已经被回收，即堆中没有这个类的实例。
* 加载该类的ClassLoader已经被回收。
* 该类对应的java.lang.Class对象没有在任何地方被引用，无法通过反射访问该类的方法。
虚拟机可以对满足上诉三个条件的无用类进行回收。

## 垃圾回收算法
几种常见的算法思想
### 标记-清除算法
算法分为“标记”和“清除”两个阶段，首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象。这种方法有两个不足之处：
* 效率问题。标记和清除两个阶段的效率都不高；
* 空间问题。标记清除后会产生大量不连续的内存碎片。

### 复制算法
将可用内存按容量划分为等大小的两块，每次只使用其中一块。当一块的内容用完，就将还存活着的对象复制到另外一块上，然后再把已使用过的内存空间一次清理掉。优点是可以避免内存碎片等复杂情况。缺点是将内存大小缩小为原来的一般，代价比较大。
现在的商业虚拟机都在这个基础上进行新生代的回收。

### 标记-整理算法
复制算法在对象存活率较高的时候需要大量的复制操作，此时效率出现问题。而分配担保的解决方案一般不适合老年代的情况。
整理的含义就是在需要清理内存的时候，把所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。

### 分代收集算法
当前的商业虚拟机的通用做法。根据对象存活周期的不同将内存划分为几块。一般是把Java堆分成新生代和老年代，新生代使用 **复制** 算法，老年代使用 **标记-清除** 或 **标记-整理** 算法。


## GC机制
GC分为两种：Minor GC、Full GC ( 或称为 Major GC )。
Minor GC是发生在新生代中的垃圾收集动作，所采用的是**复制算法**。
新生代几乎是所有 Java 对象出生的地方，即 Java 对象申请的内存以及存放都是在这个地方。Java 中的大部分对象通常不需长久存活，具有朝生夕灭的性质。
当一个对象被判定为 "死亡" 的时候，GC 就有责任来回收掉这部分对象的内存空间。新生代是 GC 收集垃圾的频繁区域。
当对象在 Eden ( 包括一个 Survivor 区域，这里假设是 from 区域 ) 出生后，在经过一次 Minor GC 后，如果对象还存活，并且能够被另外一块 Survivor 区域所容纳( 上面已经假设为 from 区域，这里应为 to 区域，即 to 区域有足够的内存空间来存储 Eden 和 from 区域中存活的对象 )，则使用复制算法将这些仍然还存活的对象复制到另外一块 Survivor 区域 ( 即 to 区域 ) 中，然后清理所使用过的 Eden 以及 Survivor 区域 ( 即 from 区域 )，并且将这些对象的年龄设置为1，以后对象在 Survivor 区每熬过一次 Minor GC，就将对象的年龄 + 1，当对象的年龄达到某个值时 ( 默认是 15 岁，可以通过参数 -XX:MaxTenuringThreshold 来设定 )，这些对象就会成为老年代。
但这也不是一定的，对于一些较大的对象 ( 即需要分配一块较大的连续内存空间 ) 则是直接进入到老年代。
Full GC 是发生在老年代的垃圾收集动作，所采用的是**标记-清除算法**。
现实的生活中，老年代的人通常会比新生代的人 "早死"。堆内存中的老年代(Old)不同于这个，老年代里面的对象几乎个个都是在 Survivor 区域中熬过来的，它们是不会那么容易就 "死掉" 了的。因此，Full GC 发生的次数不会有 Minor GC 那么频繁，并且做一次 Full GC 要比进行一次 Minor GC 的时间更长。
另外，**标记-清除**算法收集垃圾的时候会产生许多的内存碎片 ( 即不连续的内存空间 )，此后需要为较大的对象分配内存空间时，若无法找到足够的连续的内存空间，就会提前触发一次 GC 的收集动作。