---
layout: post
title: 阅读《深入理解JAVA虚拟机》2
categories: BookReading
description: 阅读笔记
keywords: 读书
---
深入理解java虚拟机 读书笔记

# 第二章 Java内存区域与内存溢出异常
## Java虚拟机规范中规定了虚拟管管理的内存中将会包含以下几个数据区域

### 1.程序计数器（Program Counter Register）
是一块比较小的内存空间，可以看作当前线程所执行的字节码的行号指示器。Java虚拟机中的多线程是通过线程轮流切换并分配处理器执行时间来实现的，所以实际上在任何一个确定的时间一个处理器的内核只能执行一条线程中的指令。即每个线程都会有一个“线程私有”的程序计数器。

### 2.Java虚拟机栈（Java Virtual Machine Stacks）
同样属于**线程私有，生命周期与线程一致**，用于存储方法的局部变量表、操作数栈、动态链表等信息，每个方法从调用到执行完成对应着一个栈帧在这个空间内入栈出栈的过程。粗糙地把Java内存分为“栈”和“堆”的话，这部分就是“栈”。保存了一些编译期可以知道大小的数据结构（boolean、byte等）、对象引用（reference类型，指向对象或者指向代表对象的句柄等）

### 3.本地方法栈（Native Method Stack）
与虚拟机栈发挥的作用类似，区别在于虚拟机栈为虚拟机执行Java方法（字节码）服务，而本地方法栈为虚拟机使用到的Native方法服务。有的虚拟机实现会把这两个栈合并到一起。

### 4.Java堆（Java Heap）
一般是内存中占用最大的一块，被所有线程共享，在虚拟机启动的时创建。用于存放对象实例，实际上程序中动态分配的空间都是从这个区域获取，同时也时垃圾收集器管理的主要区域，所以有“GC堆”（Garbage Collected Heap）的别名。可能划分出多个线程私有的分配缓冲区（Thread Local Allocation Buffer）。

### 5.方法区（Method Area）
与Java堆一样，是各个线程共享的区域，存储已被虚拟机加载的类信息、常量、静态变量等。有一个别名叫Non-Heap，用于和堆区分开。

### 6.运行时常量池（Runtime Constant Pool）
运行时常量池是方法区的一部分。Class文件中除了有类的版本、字段、方法等描述信息以外，还有一项信息是常量池表，用于存放编译期间生成的各种字面量和符号引用。

### 7.直接内存（Direct Memory）
在JDK1.4中加入NIO（New Input/Output）类，引入了一种基于通道与缓冲区的I/O新方式，可以使用Native函数库直接分配堆外内存，然后通过存储在Java堆中的DirectByteBuffer对象作为这块内存的引用进行操作。

### 对象的创建
虚拟机遇到一条new指令时，首先将去检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已经被加载、解析和初始化。加载的工作在这个阶段进行。
接下来虚拟机将为新生对象分配内存，然后将分配到的内存空间都初始化为零值（不包括对象头）。
然后，虚拟机需要对对象进行必要的设置，例如这个对象是哪个类的实例、如何才能找到类的元数据、对象的哈希码等，这些信息都放在对象的对象头中（Object Header）。从虚拟机的角度而言，此时一个新的对象已经产生了，但从Java程序的角度而言，对象的创建才刚开始，需要执行init工作。

### 对象的内存布局
对象在内存中存储的布局可以分为三个区域：对象头（Header）、实例数据（Instance Data）和对象填充（Padding）。对象头包括两个部分，一部分是自身运行时的数据（包括哈希码、GC分代年龄等，如果是数组，那么还需要存储数组的大小），另一部分是类型指针，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。

### 对象的访问定位
Java程序通过栈上的reference数据来操作堆上的具体对象。reference的访问有两种主流实现。
* 句柄
存储对象的句柄地址，句柄中包含了对象实例数据与类型数据各自的具体地址信息。
* 直接指针
堆中需要直接存储类型数据的相关信息，而reference中存储的直接就是对象地址。