---
layout: post
title: 阅读《深入理解JAVA虚拟机》3
categories: BookReading
description: 阅读笔记
keywords: 读书
---
深入理解java虚拟机 读书笔记 3

# 第三章 垃圾收集器与内存分配策略
## 判断对象已死的方法

### 1. 引用计数算法（Reference Counting）
每当有一个地方引用它时计数器加1；当引用失效时，计数器值减1；任何时刻，计数器为0的对象是不能被使用的。 缺点在于不能处理**对象之间循环引用**的问题。

### 2. 可达性分析算法（Reachability Analysis）
通过一系列称为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链（Reference Chain），当一个对象到GC Roots没有任何引用链相连（即GC Roots到这个对象不可达），则证明这个对象是不可用的。GC Roots包括以下几类
* 虚拟机栈中引用的对象
* 方法区中类静态属性引用的对象
* 方法区中常量引用的对象
* 本地方法栈中JNI（即Native方法）引用的对象

### 判断对象是否存活都和“引用”有关。
从JDK1.2后，对于“引用”的定义有所拓展，能够表示那些介于需要立即回收和不能回收之间的引用对象。即分为4种概念：
* 强引用(Strong Reference)
```类似"Object obj = new Object();"这类引用，只要这样的引用还存在，这个对象就永远不会被系统回收。```
* 软引用(Soft Reference)
```只会在系统内存快要溢出前，这些引用对象才会被列入回收范围。JDK1.2后提供了SoftReference类```
* 弱引用(Weak Reference)
```强度低于软引用，当垃圾收集器开始工作就会回收掉只被弱引用关联的对象。JDK1.2后提供了WeakReference类```
* 虚引用(Phantom Reference)
```最弱的引用，不会对对象的生存时间产生影响。为一个对象设置虚引用，可以在对象被回收的时候收到一个系统通知。JDK1.2后提供了PhantomReference类。```

### 如何被回收
即使在可达性算法中不可达的对象，在死亡之前至少要经历两次标记过程。可达性分析后没有与GC ROOTS相连接的引用链，那么会被第一次标记并进行一次筛选（查看这个对象有没有必要执行finalize()方法）。如果有必要执行，那么这个对象会被放置在一个F-Queue的队列中，然后被一个虚拟机创建的低优先级Finalizer线程执行。如果对象在这个方法里及时和引用链上的任何对象建立关联就能避免死亡。（任何对象的finalize方法只会被调用一次）

### 回收方法区
对于方法区的垃圾回收性价比不太高。在方法区进行垃圾回收主要有两个部分：废弃常量和无用的类。即一个后期没有被任何对象引用的常量值。而判定一个废弃类要求比较严苛：
* 该类的所有实例都已经被回收，即堆中没有这个类的实例。
* 加载该类的ClassLoader已经被回收。
* 该类对应的java.lang.Class对象没有在任何地方被引用，无法通过反射访问该类的方法。
