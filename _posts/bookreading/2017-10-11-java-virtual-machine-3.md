---
layout: post
title: 阅读《深入理解JAVA虚拟机》3
categories: BookReading
description: 阅读笔记
keywords: 读书
---
深入理解java虚拟机 读书笔记

# 第三章 垃圾收集器与内存分配策略
## 判断对象已死的方法

### 1. 引用计数算法（Reference Counting）
每当有一个地方引用它时计数器加1；当引用失效时，计数器值减1；任何时刻，计数器为0的对象是不能被使用的。 缺点在于不能处理**对象之间循环引用**的问题。

### 2. 可达性分析算法（Reachability Analysis）
通过一系列称为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链（Reference Chain），当一个对象到GC Roots没有任何引用链相连（即GC Roots到这个对象不可达），则证明这个对象是不可用的。GC Roots包括以下几类
* 虚拟机栈中引用的对象
* 方法区中类静态属性引用的对象
* 方法区中常量引用的对象
* 本地方法栈中JNI引用的对象

### 3.本地方法栈（Native Method Stack）
与虚拟机栈发挥的作用类似，区别在于虚拟机栈为虚拟机执行Java方法（字节码）服务，而本地方法栈为虚拟机使用到的Native方法服务。有的虚拟机实现会把这两个栈合并到一起。

### 4.Java堆（Java Heap）
一般是内存中占用最大的一块，被所有线程共享，在虚拟机启动的时创建。用于存放对象实例，实际上程序中动态分配的空间都是从这个区域获取，同时也时垃圾收集器管理的主要区域，所以有“GC堆”（Garbage Collected Heap）的别名。可能划分出多个线程私有的分配缓冲区（Thread Local Allocation Buffer）。

### 5.方法区（Method Area）
与Java堆一样，是各个线程共享的区域，存储已被虚拟机加载的类信息、常量、静态变量等。有一个别名叫Non-Heap，用于和堆区分开。

### 6.运行时常量池（Runtime Constant Pool）
运行时常量池是方法区的一部分。Class文件中除了有类的版本、字段、方法等描述信息以外，还有一项信息是常量池表，用于存放编译期间生成的各种字面量和符号引用。

### 7.直接内存（Direct Memory）
在JDK1.4中加入NIO（New Input/Output）类，引入了一种基于通道与缓冲区的I/O新方式，可以使用Native函数库直接分配堆外内存，然后通过存储在Java堆中的DirectByteBuffer对象作为这块内存的引用进行操作。

### 对象的创建
虚拟机遇到一条new指令时，首先将去检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已经被加载、解析和初始化。加载的工作在这个阶段进行。
接下来虚拟机将为新生对象分配内存，然后将分配到的内存空间都初始化为零值（不包括对象头）。
然后，虚拟机需要对对象进行必要的设置，例如这个对象是哪个类的实例、如何才能找到类的元数据、对象的哈希码等，这些信息都放在对象的对象头中（Object Header）。从虚拟机的角度而言，此时一个新的对象已经产生了，但从Java程序的角度而言，对象的创建才刚开始，需要执行init工作。

### 对象的内存布局
对象在内存中存储的布局可以分为三个区域：对象头（Header）、实例数据（Instance Data）和对象填充（Padding）。对象头包括两个部分，一部分是自身运行时的数据（包括哈希码、GC分代年龄等，如果是数组，那么还需要存储数组的大小），另一部分是类型指针，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。

### 对象的访问定位
Java程序通过栈上的reference数据来操作堆上的具体对象。reference的访问有两种主流实现。
* 句柄
存储对象的句柄地址，句柄中包含了对象实例数据与类型数据各自的具体地址信息。
* 直接指针
堆中需要直接存储类型数据的相关信息，而reference中存储的直接就是对象地址。