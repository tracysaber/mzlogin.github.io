---
layout: post
title: 阅读《深入理解JAVA虚拟机》3
categories: BookReading
description: 阅读笔记
keywords: 读书
---
深入理解java虚拟机 读书笔记 3

# 第三章 垃圾收集器与内存分配策略
## 判断对象已死的方法

### 1. 引用计数算法（Reference Counting）
每当有一个地方引用它时计数器加1；当引用失效时，计数器值减1；任何时刻，计数器为0的对象是不能被使用的。 缺点在于不能处理**对象之间循环引用**的问题。

### 2. 可达性分析算法（Reachability Analysis）
通过一系列称为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链（Reference Chain），当一个对象到GC Roots没有任何引用链相连（即GC Roots到这个对象不可达），则证明这个对象是不可用的。GC Roots包括以下几类
* 虚拟机栈中引用的对象
* 方法区中类静态属性引用的对象
* 方法区中常量引用的对象
* 本地方法栈中JNI（即Native方法）引用的对象

### 判断对象是否存活都和“引用”有关。
从JDK1.2后，对于“引用”的定义有所拓展，能够表示那些介于需要立即回收和不能回收之间的引用对象。即分为4种概念：
* 强引用(Strong Reference)
```类似"Object obj = new Object();"这类引用，只要这样的引用还存在，这个对象就永远不会被系统回收。```
* 软引用(Soft Reference)
```只会在系统内存快要溢出前，这些引用对象才会被列入回收范围。JDK1.2后提供了SoftReference类```
* 弱引用(Weak Reference)
```强度低于软引用，当垃圾收集器开始工作就会回收掉只被弱引用关联的对象。JDK1.2后提供了WeakReference类```
* 虚引用(Phantom Reference)
```最弱的引用，不会对对象的生存时间产生影响。为一个对象设置虚引用，可以在对象被回收的时候收到一个系统通知。JDK1.2后提供了PhantomReference类。```

### 如何被回收
即使在可达性算法中不可达的对象，在死亡之前至少要经历两次标记过程。可达性分析后没有与GC ROOTS相连接的引用链，那么会被第一次标记并进行一次筛选（查看这个对象有没有必要执行finalize()方法）。如果有必要执行，那么这个对象会被放置在一个F-Queue的队列中，然后被一个虚拟机创建的低优先级Finalizer线程执行。如果对象在这个方法里及时和引用链上的任何对象建立关联就能避免死亡。（任何对象的finalize方法只会被调用一次）

### 回收方法区
对于方法区的垃圾回收性价比不太高。在方法区进行垃圾回收主要有两个部分：废弃常量和无用的类。即一个后期没有被任何对象引用的常量值。而判定一个废弃类要求比较严苛：
* 该类的所有实例都已经被回收，即堆中没有这个类的实例。
* 加载该类的ClassLoader已经被回收。
* 该类对应的java.lang.Class对象没有在任何地方被引用，无法通过反射访问该类的方法。
虚拟机可以对满足上诉三个条件的无用类进行回收。

## 垃圾回收算法
几种常见的算法思想
### 标记-清除算法
算法分为“标记”和“清除”两个阶段，首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象。这种方法有两个不足之处：
* 效率问题。标记和清除两个阶段的效率都不高；
* 空间问题。标记清除后会产生大量不连续的内存碎片。

### 复制算法
将可用内存按容量划分为等大小的两块，每次只使用其中一块。当一块的内容用完，就将还存活着的对象复制到另外一块上，然后再把已使用过的内存空间一次清理掉。优点是可以避免内存碎片等复杂情况。缺点是将内存大小缩小为原来的一般，代价比较大。
现在的商业虚拟机都在这个基础上进行新生代的回收。
### 标记-整理算法
复制算法在对象存活率较高的时候需要大量的复制操作，此时效率出现问题。而分配担保的解决方案一般不适合老年代的情况。
整理的含义就是在需要清理内存的时候，把所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。
### 分代收集算法