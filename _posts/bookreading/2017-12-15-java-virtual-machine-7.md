---
layout: post
title: 阅读《深入理解JAVA虚拟机》-类加载
categories: BookReading
description: 阅读笔记
keywords: 读书
---
深入理解java虚拟机 读书笔记 7

# 第七章 虚拟机类加载机制
## 概述
虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型。在Java语言里，类型的加载、连接和初始化过程都是在程序运行期间完成的，Java里天生可以动态拓展的语言特性就是依赖运行期动态加载和动态连接这个特点实现的。例如，如果编写一个面向接口的应用程序，可以等到运行时
再指定其实际的实现类。从最基础的Applet、jsp到相对复杂的OSGi技术，都是使用了Java语言运行期间类加载的特性。
## 类加载的时机
类的整个生命周期包括：加载(Loading)、验证(Verification)、准备(Preparation)、解析(Resolution)、初始化(Initialization)、使用(Using)和卸载(Unloading)7个阶段。验证、准备、解析3个部分统称为连接(Linking)。
![图片1](/images/bookreading/jvm7/1.png)
除了解析和初始化的前后顺序不一定以外，别的过程的先后顺序是确定的。对于初始化阶段，虚拟机规范严格规定了有且只有五种情况必须立即对类进行“初始化”。
1. 遇到new,getstatic,putstatic或者invokestatic这四条字节码指令时。如果类没有进行过初始化，则需要先触发其初始化。对应的场景分别是：使用new关键词实例化对象的时候、读取或设置一个类的静态字段的时候、调用一个类的静态方法的时候。
2. 使用java.lang.reflect包的方法对类进行反射调用的时候，如果类没有进行过初始化，则要触发其初始化。
3. 当初始化一个类的时候，如果发现其父类还没有进行过初始化，则要先触发父类的初始化。
4. 当虚拟机启动时，用户需要指定一个要执行的主类（即包含main()方法的那个类），则这个类会被先初始化。
5. 当时用JDK 1.7的动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后的解析结果是某几个方法句柄，并且对应的类没有初始化，则需要先触发其初始化。

注意点 （1）对于静态字段，只有直接定义这个字段的类才会被初始化，因此通过其子类来引用父类中定义的静态字段，只会触发父类的初始化。（2）通过数组定义来引用类，不会触发此类的初始化。（3）常量在编译阶段会存入调用类的常量池中，本质上并没有直接引用到定义常量的类，因此不会触发初始化。

## 类加载的过程
### 加载
在加载阶段，虚拟机需要完成三件事。（1）通过一个类的全限定名来获取此类的二进制字节流。（2）将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。（3）在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口。
由于这个限制并不明确，所以如何获取这个二进制字节流的方法有很多方法。例如
* 从ZIP包中获取，成为日后JAR,EAR,WAR格式的基础。
* 从网络中获取，这种场景最典型的应用就是Applet。
* 运行时计算生成，多见于动态代理技术，在java.lang.reflect.Proxy中，就是用了ProxyGenerator.generateProxyClass来为特定的接口生成二进制字节流。
* 从其他文件生成，典型场景是JSP应用，即由JSP文件生成对应的Class类。
* 从数据库读取。
一个非数组类的加载阶段可以使用系统提供的引导类加载器来完成，也可以由用户自定义的类加载类去完成。开发人员可以通过定义自己的类加载器去控制字节流的获取方式。（即重写一个类加载器的loadClass()方法）。
对于数组类而言不同，数组类本身不通过类加载器创建，它是由Java虚拟机直接创建的。而数组的元素最终是要靠加载器去创建。
加载阶段完成后，虚拟机外部的二进制字节流就按照虚拟机所需的格式存储在方法区之中，方法区中的数据存储格式由虚拟机自己实现。然后在内存中实例化一个java.lang.Class类的对象，这个对象将作为程序访问方法区中的这些类型数据的外部接口。
加载阶段与连接阶段的部分内容是交叉进行的。
### 验证
验证是连接阶段的第一步，这一阶段的目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。
1. 文件格式验证
第一阶段要验证字节流是否符合Class文件格式的规范，并且能被当前版本的虚拟机处理。包括检查是否以魔数开头，主、次版本号是否在当前虚拟机处理范围内，常量池的常量中是否有不被支持的常量类型、指向常量的各种索引值中是否有指向不存在的常量或不符合类型的常量或不符合类型的常量、CONSTANT_Utf8_info型的常量是否有不符合UTF8编码的数据。
2. 元数据验证
第二阶段是对字节码描述的信息进行语义分析，以保证其描述的信息符合Java语言规范。
是否有父类、父类是否继承了不允许被继承的类、如果不是抽象类则需要实现其父类或接口中要求实现的所有方法、类的字段，方法是否和父类产生矛盾。
3. 字节码验证
第三阶段是整个验证过程中最复杂的一个阶段，主要目的是通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的。
4. 符号引用验证
最后一个阶段的校验发生在虚拟机将符号引用转化为直接引用的时候，这个转化动作将在连接的第三阶段-解析阶段发生。符号引用验证可以看做事对类自身以外的信息进行匹配性校验。包括以下内容
* 符号引用中通过字符串描述的全限定名是否能找到对应的类。
* 在指定类中是否存在符合方法的字段描述符以及简单名称所描述的方法和字段。
* 符号引用中的类、字段、方法的访问性是否可以被当前的类访问。
### 准备
准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些变量所使用的内存都将在方法区中进行分配。这时候进行内存分配的仅包括类变量（被static修饰的变量），而不包括实例变量，实例变量将会在对象实例化时随着对象一起分配在Java堆中。而这个初始值通常是数据类型的零值。而实际的赋值工作需要等到程序被编译之后，存放在类构造器<clinit>()方法中。
### 解析
解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。
* 符号引用（Symbolic References）:符号引用以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要能无歧义地定位到目标即可。
* 直接引用（Direct References）：直接引用可以是直接指向目标的指针、相对偏移量或是一个能直接定位到目标的句柄。
### 初始化
类初始化时类加载过程的最后一步。到这一阶段才真正开始执行类中定义的Java代码。在这个阶段会根据程序员制定的主观计划去初始化类变量和其他资源。
* <clinit>()方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块（static{}块）中的语句块合并产生的。
* <clinit>()方法与类的构造函数（<init>()方法）不同，它不需要显式地调用父类构造器，虚拟机保证子类的<clinit>()方法执行之前父类的已经执行完毕。
* 由于父类的<clinit>()方法先执行，即父类的静态函数先被执行。
* 接口中不能使用静态语句块，但仍然变量初始化的赋值操作。
## 类加载器
### 类与类加载器
类加载器虽然只用于实现类的加载动作，但起的作用远不限于此。对于任意一个类，都需要由加载它的类加载器和类本身一同确立在Java虚拟机中的唯一性。
### 双亲委派模型
从Java虚拟机的角度讲，只存在两种不同的类加载器：一种是启动类加载器(Bootstrap ClassLoader)，是虚拟机的一部分；另一种就是所有其他的类加载器，这些类加载器都由Java语言实现，独立于虚拟机外部，并且全都继承自抽象类java.lang.ClassLoader。从开发人员的角度来看，可以分得更细致一点。
* 启动类加载器：负责将存放在<JAVA_HOME>\lib目录中的，或者被-Xbootclasspath参数所指定的路径中，文件名能被识别的类库加载到虚拟机的内存中。无法被Java程序直接引用，用户在编写自定义类加载器时，如果需要把加载请求委派给引导类加载器，直接使用null替代即可。
* 拓展类加载器：这个加载器由sum.misc.Launcher$ExtClassLoader实现，它负责加载<JAVA_HOME>\lib\ext目录中的类库，开发者可以直接使用扩展类加载器。
* 应用程序类加载器：这个类加载器由sun.misc.Launcher$AppClassLoader实现。由于这个类加载器是ClassLoader中的getSystemClassLoader()方法的返回值，即系统类加载器。它负责加载用户类路径上所指定的类库，开发者可以直接使用这个类加载器，一般是程序中的默认的类加载器。

![图片2](/images/bookreading/jvm7/2.png)

双亲委派模型的工作过程是：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把请求委派给父类加载器去完成，因此所有的加载请求最终都应该传送到顶层的启动类加载器中，只有当父加载器反馈无法完成加载的时候，子加载器才会尝试自己去加载。
这么做有一个显而易见的好处就是Java类随着它的类加载器一起具备了一种带有优先级的层次关系。否则系统中可能出现多个同名类产生问题。