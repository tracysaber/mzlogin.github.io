---
layout: post
title: java基础-面向对象等
categories: Java基础
description: 没有靠谱描述
keywords: java
---
面向对象

# 语言知识
## 面向对象的知识
面向对象的主要特征包括抽象、继承、封装和*多态*。
1. 继承。
* class 子类 extends 父类。
* Java不支持多重继承，一个子类最多只能有一个父类，但是可以实现多个接口达到多重继承的目的。
* 子类只能继承父类的非私有成员变量和方法。
* 成员变量重名时子类会覆盖父类的变量。
* 相同的函数子类会重写父类的方法。
2. 组合和继承的区别
* 继承关系是一种is-a的关系，可以理解为一对一的关系。而组合关系是一种has-a的关系，一对多。
* 过多地使用继承会破坏代码维护性，所以组合优先于继承。
3. 多态的实现机制
多态表示当同一个操作作用在不同对象时，会有不同的语义，从而产生不同的效果。常见的有以下几种实现方式。
* 方法的**重载**(overload)。一个类中有多个同名的方法，但是这些方法有着不同的参数，因此在编译的时候就可以确定到底调用的是哪一种方法，是一种编译时多态。
* 方法的**覆盖**(override)。子类可以覆盖父类的方法，这样同样的方法会在父类和子类中有不同的实现，而*基类的引用变量*不仅可以指向*基类的实例对象*，也可以指向*子类的实例对象*，*接口的引用变量*同样也可以指向其*实现类的实例对象*。而程序调用的方法在运行期才会动态绑定。这样通过方法覆盖实现的多态被称为运行时多态。
而成员变量无法用这样的方式实现多态，成员变量的值是父类还是子类取决于定义变量的类型。
4. 重载和覆盖有什么区别
重载(overload)和覆盖(override)是Java多态性的不同表现方式。
* 重载通过不同的方法参数来区分，例如不同的参数个数、不同的参数类型或者顺序。
* 不能通过方法的访问权限、返回值类型和抛出的异常类型来进行重载。
* 对于继承来说，如果基类方法的访问权限为private，那么就不能在派生类对其重载。
覆盖是指派生类函数覆盖基类函数。
* 派生类中的覆盖方法必须要和基类中被覆盖的方法有相同的函数名和参数，相同的返回值，抛出的异常一致。
* 被覆盖的方法不能为private，否则就定义了一个新的方法。
由此二者的区别如下
* 覆盖是子类和父类的关系，属于垂直关系；重载是同一个类中方法之间的关系，属于水平关系。
* 覆盖只能由一个方法或者一对方法产生关系；重载是多个方法之间的关系。
* 覆盖要求参数列表相同；重载要求参数列表不同。
5. 抽象类与接口的异同
一个包含抽象方法的类就是抽象类(abstract class)。abstract只能用来修饰类或者方法。接口是指一个方法的集合，通过关键词interface来修饰。
抽象类*不能被实例化*，但是可以创建一个对象来指向具体子类的一个实例。
方法体在实现时必须包含*相同或者更低的访问级*。
接口中所有的方法都是抽象的，可以通过接口来间接地实现多重继承。接口中的成员变量默认都是static final类型。所以在设定成员变量的时候需要赋初值。
总结两者相同点：
	1. 都不能被实例化。
	2. 只有方法都被实现后才能被实例化。

不同点如下：

	1. 接口只有定义，其方法不能在接口中实现。而抽象类中可以有被实现的方法。
	2. 接口需要实现implements，但抽象类只能被继承extends。一个类可以实现多个接口但只能继承一个类。
	3. 接口所有的方法都是public abstract 修饰的。功能需要累积的时候用抽象类，反之用接口。
	4. 接口被运用于实现比较常见的功能，便于日后维护或者添加删除方法；而抽象类更倾向于充当公共类的角色。

## 零碎知识点

1. 内部类
在Java语言当中，可以把一个类定义到另外一个类的内部，这个类就叫内部类。外面的叫做外部类。这种情况下，这个内部类可以看作外部类的成员。
2. this和super的区别
this用来指向当前的实例对象，有一个非常主要的作用就是区分对象的成员变量与方法的形式参数。
super可以用来访问父类的方法和成员变量。
3.匿名内部类
没有访问修饰符、构造方法等，所在方法的形参被匿名内部类使用的时候，必须为final类型。（内部类都有这个性质）