---
layout: post
title: java基础-多线程，并发等
categories: Java基础
description: 没有靠谱描述
keywords: java
---
多线程、并发、同步、异常、IO

# 语言知识
## 多线程问题
在Java语言中，线程有四种状态，*运行*，*就绪*，*挂起*，*结束*。

### 多线程的实现方法
1. 继承Thread类，重写run()方法
2. 实现Runable接口，并实现run()方法
3. 实现Callable接口，重写call()方法
* Callable可以在任务结束后提供一个返回值，Runable没有这个功能。
* Callable的call()方法可以抛出异常
* 运行Callable可以拿到一个Future对象，表示异步计算的结果，它提供了检查计算是否完成的方法。由于线程属于异步计算模型，因此无法从别的线程中得到函数的返回值，这样就可以用Future来监视目标线程调用call()方法的情况，

### 多线程同步的实现方法有哪些
1. synchronized关键字
Java中的每一个对象都可以作为锁。
* 对于同步方法，锁是当前实例对象。
* 对于静态同步方法，锁是当前对象的Class对象。
* 对于同步方法块，锁是Synchonized括号里配置的对象。
当一个线程试图访问同步代码块时，它首先必须得到锁，退出或抛出异常时必须释放锁。
2. wait()方法和notify()方法
3. Lock
* lock()。以阻塞的方式获取锁。等待直到获取锁。
* tryLock(long timeout,TimeUnit unit)。如果获取到了锁返回True，否则等待相应的时间单元，期间如果得到锁就返回True，否则到时就返回False。
* lockInterruptibly()。主要区别在于如果获取不到锁，当前线程就会处于休眠的状态。

### synchronized与Lock有什么异同
1. 用法不一样。synchronized既可以加载方法上，也可以加在特定代码块中，括号中表示需要加锁的对象。而Lock需要显示地指定起始位置和终止位置。synchrozied是托管给JVM去操作的，而Lock的锁定是通过自己编写代码实现的，有着更精确的线程语义。
2. 性能不一样。在JDK5中增加了Lock接口的实现类ReentrantLock。和synchronized有着相同的并发性和内存语义，在资源竞争比较激烈的情况下ReentrantLock性能比较好，反之synchronized比较占优势。
3. 锁机制不一样。synchronized获取锁和释放都是在块结构中，当获取多个锁时，必须以相反的顺序释放，而且是自动解锁。Lock则需要开发人员手动去释放锁，并且必须在finally中释放。

### 乐观锁和悲观锁
**悲观锁** ：假定会发生并发冲突，屏蔽一切可能违反数据完整性的操作。
**乐观锁** ：假设不会发生并发冲突，只在提交操作时检查是否违反数据完整性。乐观锁不能解决脏读的问题。

独占锁是一种悲观锁，Java中synchronized就是一种独占锁。有着比较大的开销。
CAS(Compare and Swap)是一种乐观锁，每次不加锁，而是假设没有冲突去完成某个操作。如果失败就重试，直到成功。
CAS中存在着三个值，一个是内存位置的值V，一个是旧的预期值A，一个是新值B。指令执行时，当且仅当V符合旧预期值A时，处理器用新值B更新V的值，否则它就不执行更新，但是无论是否更新了V的值，都会返回V的旧值，上述的处理过程是一个原子操作。

### 守护进程
守护进程又被称为服务进程、后台进程。在后台提供一种通用服务，并不属于程序中不可或缺的一部分。
守护线程一般拥有比较低的优先级，用户在编程的时候也可以自己设置守护线程，在调用start()之前调用对象的setDaemon(true)方法。守护线程产生的线程默认也是守护线程，同样的用户线程默认产生的也是用户线程。当程序中只有守护线程的时候，JVM可以退出。

### join()方法
让调用该方法的线程在执行完run()之后，

## Java异常
![异常图](/images/java/throwable.png)
### Throwable
是Java中所有错误和异常的超类。Error和Excetion都是它的子类。
### Error
系统错误，用户无法操作，一般由JVM去处理。
### Exception
程序可以处理的异常，分成 **CheckedException** (受检异常)和 **UncheckedException** (不受检异常)。
#### 受检异常
最常见的异常，最常见的就是 **IOException** 和 **SQLException** 。发生在编译阶段，Java强制程序去捕获这类异常。
#### 不受检异常(运行时异常)
常见的包括空指针异常、类型转换异常、数组越界异常、数组存储异常、缓冲区溢出异常、算术异常等。

## Java IO 
![IO结构图](/images/java/io.png)
### 字符流和字节流
流序列中的数据既可以是未经加工的原始二进制数据，也可以是经一定编码处理后符合某种格式规定的特定数据。因此Java中的流分为两种：
* 字节流：数据流中最小的数据单元是字节
* 字符流：数据流中最小的数据单元是字符， Java中的字符是Unicode编码，一个字符占用两个字节。

字符流的由来： Java中字符是采用Unicode标准，一个字符是16位，即一个字符使用两个字节来表示。为此，JAVA中引入了处理字符的流。因为数据编码的不同，而有了对字符进行高效操作的流对象。本质其实就是基于字节流读取时，去查了指定的码表。
