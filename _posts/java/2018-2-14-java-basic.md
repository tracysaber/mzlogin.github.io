---
layout: post
title: java基础-内存关键词等
categories: Java基础
description: 没有靠谱描述
keywords: java
---
java面试会考察的基础知识点

# 语言知识
## 八种基本数据类型
* 四种整数类型 **byte-8** , **short-16** , **int-32** , **long-64** ,整数字面量默认都为 int 类型，所以在定义的 long 型数据后面加 L或 l。
* 两种浮点数类型 **float-32** , **double 64** ,float :后缀 F 或 f，1 位符号位，8 位指数，23 位有效尾数。double:64 位，后缀 D 或 d，1 位符号位，11 位指数，52 位有效尾数。
* 一种字符类型 **char-16** ,本质上就是一个数字。
* 一种布尔类型 **boolean** ,true or false。

## 关键词权限问题

| 关键词  |   类内    |   子类  |   包内  |   包外   |
| :-----: | :------:| :-----: | :-----: |  :-----: |
| public | √ | √ | √ |   √      |
| protected | √ | √ | √ |   ×      |
| default | √ | √ | × |    ×     |
| private | √ | × | × |     ×    |

## Comparator和Comparable的区别

|参数	|Comparable	|Comparator|
| :-----: | :------:| :-----: | 
|排序逻辑	|排序逻辑必须在待排序对象的类中，故称之为自然排序	|排序逻辑在另一个实现|
|实现	|实现Comparable接口	|实现Comparator接口|
|排序方法	|int compareTo(Object o1)	|int compare(Object o1,Object o2)|
|触发排序	|Collections.sort(List)|	Collections.sort(List, Comparator)|
|接口所在包	|java.lang.Comparable	|java.util.Comparator|

## Java是否存在内存泄漏的问题

```shell
回答：存在，如下几种情况都有可能发生内存泄漏
1.静态集合类。比如HashMap这类数据结构，如果这些容器是静态的，由于他们的生命周期和程序一致，
所以容器内的对象在容器的生命周期结束之前不会被释放。
2.各种连接。比如数据库、网络等等。如果访问数据库的过程中对Connection、Statement等不显式关闭，
将会造成大量的对象无法被回收，从而引起内存泄漏。
3.监听器。
4.变量不合理的作用域。
5.单例模式。单例模式使用静态存储，如果错误使用引用而不及时释放，就会出现内存泄漏。

```

## Java程序的初始化顺序
1. 静态对象（变量）优先于非静态变量，但静态变量只初始化一次，非静态变量可能被初始化多次。
2. 父类优先于子类进行初始化。
3. 按照成员变量的定义顺序进行初始化。变量定义优先于任何方法（包括构造函数）被初始化。
顺序：父类静态变量->父类静态代码块->子类静态变量->子类静态代码块->父类非静态变量->父类非静态代码块->父类构造函数->子类非静态变量->子类非静态代码块->子类构造函数

## Java的clone方法
* Java在处理基本数据类型（int,char,double等）时，都是采用值传递（即输入数据的复制）。除此以外的其他类型都是按照引用传递。用“=”赋值的时候也采用引用赋值。
* 如果需要创建一个和某个对象一样的非基本数据类型时，需要调用clone方法。用户要做的就是在类中重写Cloneable接口的clone方法，实现clone功能。
* **浅复制** 被复制对象的所有对象都含有与原来对象相同的值，而所有对象其他对象的引用仍然指向原来的对象。
* **深复制** 被复制对象的所有对象都含有与原来对象相同的值，引用其他对象的变量将指向被复制的新对象。

## 反射机制
反射机制提供的功能包括以下几个。
* 得到一个对象所属的类。
* 获取一个类所有的成员变量和方法。
* 在运行时创建对象。
* 在运行时调用对象的方法。
其中反射机制最重要的一点就是能在运行的时候动态地创建类的对象。

反射获取类的方法
1. class.forName("类的路径")
2. 类型.class
3. 实例.getClass()

Java中创建对象的几种方式
1. new语句实例化一个对象。
2. 通过反射机制创建对象。
3. 通过clone()方法创建一个对象。
4. 通过反序列化创建一个对象。

## Java关键词的知识点

### break,continue,return比较
1. break可以直接强行跳出当前循环，当出现多层嵌套的时候，break只能跳出当前的循环。
2. continue用于停止当次循环，回到循环开始处，进入下一次循环操作。
3. return是一个跳转语句，用来表示从一个方法返回，使程序控制回到调用这个方法的地方去。

### final,finally,finalize的区别

1. final用于申明属性、方法和类，分别表示属性不可变、方法不可覆盖和类不可被继承。
2. finally 作为异常处理的一部分，只能在try/catch语句中，并且是一个一定会被执行的语句块。
3. finalize是Object类的一个方法，在垃圾回收时被执行。

### static关键词的作用
* 为某特定的数据类型或对象分配单一的存储空间，而与对象的数量无关。
* 实现某个方法或者属性与类而不是对象关联在一起。
注意点：
1. Java中不能在方法体里定义static变量。
2. static方法中不能使用this和super关键词。
3. static代码块可以用来初始化静态变量。

### volatile关键词
在多线程的环境中，每个线程都有自己的缓存空间，用于存放一些常用的变量。但可能出现某个线程把自己缓存中的对象值改变了但没有改变实际内存中的值，导致数据不一致。
**volatile** 是个类型修饰符，被修饰的对象每次被使用时都是从内存中获取，而不利用缓存。但无法保证原子性。